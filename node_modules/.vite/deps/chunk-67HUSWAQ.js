import {
  __commonJS,
  __export,
  __publicField,
  __toESM
} from "./chunk-2TUXWMP5.js";

// node_modules/boolbase/index.js
var require_boolbase = __commonJS({
  "node_modules/boolbase/index.js"(exports, module) {
    module.exports = {
      trueFunc: function trueFunc() {
        return true;
      },
      falseFunc: function falseFunc() {
        return false;
      }
    };
  }
});

// node_modules/unist-util-is/lib/index.js
var convert = (
  // Note: overloads in JSDoc can’t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(test2) {
    if (test2 === null || test2 === void 0) {
      return ok;
    }
    if (typeof test2 === "function") {
      return castFactory(test2);
    }
    if (typeof test2 === "object") {
      return Array.isArray(test2) ? anyFactory(test2) : propsFactory(test2);
    }
    if (typeof test2 === "string") {
      return typeFactory(test2);
    }
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory(tests) {
  const checks2 = [];
  let index = -1;
  while (++index < tests.length) {
    checks2[index] = convert(tests[index]);
  }
  return castFactory(any);
  function any(...parameters) {
    let index2 = -1;
    while (++index2 < checks2.length) {
      if (checks2[index2].apply(this, parameters)) return true;
    }
    return false;
  }
}
function propsFactory(check) {
  const checkAsRecord = (
    /** @type {Record<string, unknown>} */
    check
  );
  return castFactory(all3);
  function all3(node) {
    const nodeAsRecord = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      node
    );
    let key;
    for (key in check) {
      if (nodeAsRecord[key] !== checkAsRecord[key]) return false;
    }
    return true;
  }
}
function typeFactory(check) {
  return castFactory(type);
  function type(node) {
    return node && node.type === check;
  }
}
function castFactory(testFunction) {
  return check;
  function check(value, index, parent) {
    return Boolean(
      looksLikeANode(value) && testFunction.call(
        this,
        value,
        typeof index === "number" ? index : void 0,
        parent || void 0
      )
    );
  }
}
function ok() {
  return true;
}
function looksLikeANode(value) {
  return value !== null && typeof value === "object" && "type" in value;
}

// node_modules/unist-util-visit-parents/lib/color.js
function color(d) {
  return d;
}

// node_modules/unist-util-visit-parents/lib/index.js
var empty = [];
var CONTINUE = true;
var EXIT = false;
var SKIP = "skip";
function visitParents(tree, test2, visitor, reverse) {
  let check;
  if (typeof test2 === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test2;
  } else {
    check = test2;
  }
  const is3 = convert(check);
  const step = reverse ? -1 : 1;
  factory2(tree, void 0, [])();
  function factory2(node, index, parents) {
    const value = (
      /** @type {Record<string, unknown>} */
      node && typeof node === "object" ? node : {}
    );
    if (typeof value.type === "string") {
      const name2 = (
        // `hast`
        typeof value.tagName === "string" ? value.tagName : (
          // `xast`
          typeof value.name === "string" ? value.name : void 0
        )
      );
      Object.defineProperty(visit2, "name", {
        value: "node (" + color(node.type + (name2 ? "<" + name2 + ">" : "")) + ")"
      });
    }
    return visit2;
    function visit2() {
      let result = empty;
      let subresult;
      let offset;
      let grandparents;
      if (!test2 || is3(node, index, parents[parents.length - 1] || void 0)) {
        result = toResult(visitor(node, parents));
        if (result[0] === EXIT) {
          return result;
        }
      }
      if ("children" in node && node.children) {
        const nodeAsParent = (
          /** @type {UnistParent} */
          node
        );
        if (nodeAsParent.children && result[0] !== SKIP) {
          offset = (reverse ? nodeAsParent.children.length : -1) + step;
          grandparents = parents.concat(nodeAsParent);
          while (offset > -1 && offset < nodeAsParent.children.length) {
            const child = nodeAsParent.children[offset];
            subresult = factory2(child, offset, grandparents)();
            if (subresult[0] === EXIT) {
              return subresult;
            }
            offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
          }
        }
      }
      return result;
    }
  }
}
function toResult(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE, value];
  }
  return value === null || value === void 0 ? empty : [value];
}

// node_modules/unist-util-visit/lib/index.js
function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
  let reverse;
  let test2;
  let visitor;
  if (typeof testOrVisitor === "function" && typeof visitorOrReverse !== "function") {
    test2 = void 0;
    visitor = testOrVisitor;
    reverse = visitorOrReverse;
  } else {
    test2 = testOrVisitor;
    visitor = visitorOrReverse;
    reverse = maybeReverse;
  }
  visitParents(tree, test2, overload, reverse);
  function overload(node, parents) {
    const parent = parents[parents.length - 1];
    const index = parent ? parent.children.indexOf(node) : void 0;
    return visitor(node, index, parent);
  }
}

// node_modules/property-information/lib/util/schema.js
var Schema = class {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(property, normal, space) {
    this.normal = normal;
    this.property = property;
    if (space) {
      this.space = space;
    }
  }
};
Schema.prototype.normal = {};
Schema.prototype.property = {};
Schema.prototype.space = void 0;

// node_modules/property-information/lib/util/merge.js
function merge(definitions, space) {
  const property = {};
  const normal = {};
  for (const definition of definitions) {
    Object.assign(property, definition.property);
    Object.assign(normal, definition.normal);
  }
  return new Schema(property, normal, space);
}

// node_modules/property-information/lib/normalize.js
function normalize(value) {
  return value.toLowerCase();
}

// node_modules/property-information/lib/util/info.js
var Info = class {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(property, attribute2) {
    this.attribute = attribute2;
    this.property = property;
  }
};
Info.prototype.attribute = "";
Info.prototype.booleanish = false;
Info.prototype.boolean = false;
Info.prototype.commaOrSpaceSeparated = false;
Info.prototype.commaSeparated = false;
Info.prototype.defined = false;
Info.prototype.mustUseProperty = false;
Info.prototype.number = false;
Info.prototype.overloadedBoolean = false;
Info.prototype.property = "";
Info.prototype.spaceSeparated = false;
Info.prototype.space = void 0;

// node_modules/property-information/lib/util/types.js
var types_exports = {};
__export(types_exports, {
  boolean: () => boolean,
  booleanish: () => booleanish,
  commaOrSpaceSeparated: () => commaOrSpaceSeparated,
  commaSeparated: () => commaSeparated,
  number: () => number,
  overloadedBoolean: () => overloadedBoolean,
  spaceSeparated: () => spaceSeparated
});
var powers = 0;
var boolean = increment();
var booleanish = increment();
var overloadedBoolean = increment();
var number = increment();
var spaceSeparated = increment();
var commaSeparated = increment();
var commaOrSpaceSeparated = increment();
function increment() {
  return 2 ** ++powers;
}

// node_modules/property-information/lib/util/defined-info.js
var checks = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys(types_exports)
);
var DefinedInfo = class extends Info {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(property, attribute2, mask, space) {
    let index = -1;
    super(property, attribute2);
    mark(this, "space", space);
    if (typeof mask === "number") {
      while (++index < checks.length) {
        const check = checks[index];
        mark(this, checks[index], (mask & types_exports[check]) === types_exports[check]);
      }
    }
  }
};
DefinedInfo.prototype.defined = true;
function mark(values, key, value) {
  if (value) {
    values[key] = value;
  }
}

// node_modules/property-information/lib/util/create.js
function create(definition) {
  const properties = {};
  const normals = {};
  for (const [property, value] of Object.entries(definition.properties)) {
    const info = new DefinedInfo(
      property,
      definition.transform(definition.attributes || {}, property),
      value,
      definition.space
    );
    if (definition.mustUseProperty && definition.mustUseProperty.includes(property)) {
      info.mustUseProperty = true;
    }
    properties[property] = info;
    normals[normalize(property)] = property;
    normals[normalize(info.attribute)] = property;
  }
  return new Schema(properties, normals, definition.space);
}

// node_modules/property-information/lib/aria.js
var aria = create({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: booleanish,
    ariaAutoComplete: null,
    ariaBusy: booleanish,
    ariaChecked: booleanish,
    ariaColCount: number,
    ariaColIndex: number,
    ariaColSpan: number,
    ariaControls: spaceSeparated,
    ariaCurrent: null,
    ariaDescribedBy: spaceSeparated,
    ariaDetails: null,
    ariaDisabled: booleanish,
    ariaDropEffect: spaceSeparated,
    ariaErrorMessage: null,
    ariaExpanded: booleanish,
    ariaFlowTo: spaceSeparated,
    ariaGrabbed: booleanish,
    ariaHasPopup: null,
    ariaHidden: booleanish,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: spaceSeparated,
    ariaLevel: number,
    ariaLive: null,
    ariaModal: booleanish,
    ariaMultiLine: booleanish,
    ariaMultiSelectable: booleanish,
    ariaOrientation: null,
    ariaOwns: spaceSeparated,
    ariaPlaceholder: null,
    ariaPosInSet: number,
    ariaPressed: booleanish,
    ariaReadOnly: booleanish,
    ariaRelevant: null,
    ariaRequired: booleanish,
    ariaRoleDescription: spaceSeparated,
    ariaRowCount: number,
    ariaRowIndex: number,
    ariaRowSpan: number,
    ariaSelected: booleanish,
    ariaSetSize: number,
    ariaSort: null,
    ariaValueMax: number,
    ariaValueMin: number,
    ariaValueNow: number,
    ariaValueText: null,
    role: null
  },
  transform(_, property) {
    return property === "role" ? property : "aria-" + property.slice(4).toLowerCase();
  }
});

// node_modules/property-information/lib/util/case-sensitive-transform.js
function caseSensitiveTransform(attributes, attribute2) {
  return attribute2 in attributes ? attributes[attribute2] : attribute2;
}

// node_modules/property-information/lib/util/case-insensitive-transform.js
function caseInsensitiveTransform(attributes, property) {
  return caseSensitiveTransform(attributes, property.toLowerCase());
}

// node_modules/property-information/lib/html.js
var html = create({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: commaSeparated,
    acceptCharset: spaceSeparated,
    accessKey: spaceSeparated,
    action: null,
    allow: null,
    allowFullScreen: boolean,
    allowPaymentRequest: boolean,
    allowUserMedia: boolean,
    alt: null,
    as: null,
    async: boolean,
    autoCapitalize: null,
    autoComplete: spaceSeparated,
    autoFocus: boolean,
    autoPlay: boolean,
    blocking: spaceSeparated,
    capture: null,
    charSet: null,
    checked: boolean,
    cite: null,
    className: spaceSeparated,
    cols: number,
    colSpan: null,
    content: null,
    contentEditable: booleanish,
    controls: boolean,
    controlsList: spaceSeparated,
    coords: number | commaSeparated,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: boolean,
    defer: boolean,
    dir: null,
    dirName: null,
    disabled: boolean,
    download: overloadedBoolean,
    draggable: booleanish,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: boolean,
    formTarget: null,
    headers: spaceSeparated,
    height: number,
    hidden: boolean,
    high: number,
    href: null,
    hrefLang: null,
    htmlFor: spaceSeparated,
    httpEquiv: spaceSeparated,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: boolean,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: boolean,
    itemId: null,
    itemProp: spaceSeparated,
    itemRef: spaceSeparated,
    itemScope: boolean,
    itemType: spaceSeparated,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: boolean,
    low: number,
    manifest: null,
    max: null,
    maxLength: number,
    media: null,
    method: null,
    min: null,
    minLength: number,
    multiple: boolean,
    muted: boolean,
    name: null,
    nonce: null,
    noModule: boolean,
    noValidate: boolean,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: boolean,
    optimum: number,
    pattern: null,
    ping: spaceSeparated,
    placeholder: null,
    playsInline: boolean,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: boolean,
    referrerPolicy: null,
    rel: spaceSeparated,
    required: boolean,
    reversed: boolean,
    rows: number,
    rowSpan: number,
    sandbox: spaceSeparated,
    scope: null,
    scoped: boolean,
    seamless: boolean,
    selected: boolean,
    shadowRootClonable: boolean,
    shadowRootDelegatesFocus: boolean,
    shadowRootMode: null,
    shape: null,
    size: number,
    sizes: null,
    slot: null,
    span: number,
    spellCheck: booleanish,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: number,
    step: null,
    style: null,
    tabIndex: number,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: boolean,
    useMap: null,
    value: booleanish,
    width: number,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: spaceSeparated,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: number,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: number,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: boolean,
    // Lists. Use CSS to reduce space between items instead
    declare: boolean,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: number,
    // `<img>` and `<object>`
    leftMargin: number,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: number,
    // `<body>`
    marginWidth: number,
    // `<body>`
    noResize: boolean,
    // `<frame>`
    noHref: boolean,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: boolean,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: boolean,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: number,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: booleanish,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: number,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: number,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: boolean,
    disableRemotePlayback: boolean,
    prefix: null,
    property: null,
    results: number,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: caseInsensitiveTransform
});

// node_modules/property-information/lib/svg.js
var svg = create({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: commaOrSpaceSeparated,
    accentHeight: number,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: number,
    amplitude: number,
    arabicForm: null,
    ascent: number,
    attributeName: null,
    attributeType: null,
    azimuth: number,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: number,
    by: null,
    calcMode: null,
    capHeight: number,
    className: spaceSeparated,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: number,
    diffuseConstant: number,
    direction: null,
    display: null,
    dur: null,
    divisor: number,
    dominantBaseline: null,
    download: boolean,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: number,
    enableBackground: null,
    end: null,
    event: null,
    exponent: number,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: number,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: commaSeparated,
    g2: commaSeparated,
    glyphName: commaSeparated,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: number,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: number,
    horizOriginX: number,
    horizOriginY: number,
    id: null,
    ideographic: number,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: number,
    k: number,
    k1: number,
    k2: number,
    k3: number,
    k4: number,
    kernelMatrix: commaOrSpaceSeparated,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: number,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: number,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: number,
    overlineThickness: number,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: number,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: spaceSeparated,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: number,
    pointsAtY: number,
    pointsAtZ: number,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: commaOrSpaceSeparated,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: commaOrSpaceSeparated,
    rev: commaOrSpaceSeparated,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: commaOrSpaceSeparated,
    requiredFeatures: commaOrSpaceSeparated,
    requiredFonts: commaOrSpaceSeparated,
    requiredFormats: commaOrSpaceSeparated,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: number,
    specularExponent: number,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: number,
    strikethroughThickness: number,
    string: null,
    stroke: null,
    strokeDashArray: commaOrSpaceSeparated,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: number,
    strokeOpacity: number,
    strokeWidth: null,
    style: null,
    surfaceScale: number,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: commaOrSpaceSeparated,
    tabIndex: number,
    tableValues: null,
    target: null,
    targetX: number,
    targetY: number,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: commaOrSpaceSeparated,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: number,
    underlineThickness: number,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: number,
    values: null,
    vAlphabetic: number,
    vMathematical: number,
    vectorEffect: null,
    vHanging: number,
    vIdeographic: number,
    version: null,
    vertAdvY: number,
    vertOriginX: number,
    vertOriginY: number,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: number,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: caseSensitiveTransform
});

// node_modules/property-information/lib/xlink.js
var xlink = create({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(_, property) {
    return "xlink:" + property.slice(5).toLowerCase();
  }
});

// node_modules/property-information/lib/xmlns.js
var xmlns = create({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: caseInsensitiveTransform
});

// node_modules/property-information/lib/xml.js
var xml = create({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(_, property) {
    return "xml:" + property.slice(3).toLowerCase();
  }
});

// node_modules/property-information/lib/hast-to-react.js
var hastToReact = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
};

// node_modules/property-information/lib/find.js
var cap = /[A-Z]/g;
var dash = /-[a-z]/g;
var valid = /^data[-\w.:]+$/i;
function find(schema, value) {
  const normal = normalize(value);
  let property = value;
  let Type = Info;
  if (normal in schema.normal) {
    return schema.property[schema.normal[normal]];
  }
  if (normal.length > 4 && normal.slice(0, 4) === "data" && valid.test(value)) {
    if (value.charAt(4) === "-") {
      const rest = value.slice(5).replace(dash, camelcase);
      property = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
    } else {
      const rest = value.slice(4);
      if (!dash.test(rest)) {
        let dashes = rest.replace(cap, kebab);
        if (dashes.charAt(0) !== "-") {
          dashes = "-" + dashes;
        }
        value = "data" + dashes;
      }
    }
    Type = DefinedInfo;
  }
  return new Type(property, value);
}
function kebab($0) {
  return "-" + $0.toLowerCase();
}
function camelcase($0) {
  return $0.charAt(1).toUpperCase();
}

// node_modules/property-information/index.js
var html2 = merge([aria, html, xlink, xmlns, xml], "html");
var svg2 = merge([aria, svg, xlink, xmlns, xml], "svg");

// node_modules/css-selector-parser/dist/mjs/indexes.js
var emptyMulticharIndex = {};
var emptyRegularIndex = {};
function extendIndex(item, index) {
  var currentIndex = index;
  for (var pos = 0; pos < item.length; pos++) {
    var isLast = pos === item.length - 1;
    var char = item.charAt(pos);
    var charIndex = currentIndex[char] || (currentIndex[char] = { chars: {} });
    if (isLast) {
      charIndex.self = item;
    }
    currentIndex = charIndex.chars;
  }
}
function createMulticharIndex(items) {
  if (items.length === 0) {
    return emptyMulticharIndex;
  }
  var index = {};
  for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
    var item = items_1[_i];
    extendIndex(item, index);
  }
  return index;
}
function createRegularIndex(items) {
  if (items.length === 0) {
    return emptyRegularIndex;
  }
  var result = {};
  for (var _i = 0, items_2 = items; _i < items_2.length; _i++) {
    var item = items_2[_i];
    result[item] = true;
  }
  return result;
}

// node_modules/css-selector-parser/dist/mjs/pseudo-signatures.js
var emptyPseudoSignatures = {};
var defaultPseudoSignature = {
  type: "String",
  optional: true
};
function calculatePseudoSignature(types) {
  var result = {
    type: "NoArgument",
    optional: false
  };
  function setResultType(type2) {
    if (result.type && result.type !== type2 && result.type !== "NoArgument") {
      throw new Error('Conflicting pseudo-class argument type: "'.concat(result.type, '" vs "').concat(type2, '".'));
    }
    result.type = type2;
  }
  for (var _i = 0, types_1 = types; _i < types_1.length; _i++) {
    var type = types_1[_i];
    if (type === "NoArgument") {
      result.optional = true;
    }
    if (type === "Formula") {
      setResultType("Formula");
    }
    if (type === "FormulaOfSelector") {
      setResultType("Formula");
      result.ofSelector = true;
    }
    if (type === "String") {
      setResultType("String");
    }
    if (type === "Selector") {
      setResultType("Selector");
    }
  }
  return result;
}
function inverseCategories(obj) {
  var result = {};
  for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {
    var category = _a[_i];
    var items = obj[category];
    if (items) {
      for (var _b = 0, _c = items; _b < _c.length; _b++) {
        var item = _c[_b];
        (result[item] || (result[item] = [])).push(category);
      }
    }
  }
  return result;
}
function calculatePseudoSignatures(definitions) {
  var pseudoClassesToArgumentTypes = inverseCategories(definitions);
  var result = {};
  for (var _i = 0, _a = Object.keys(pseudoClassesToArgumentTypes); _i < _a.length; _i++) {
    var pseudoClass = _a[_i];
    var argumentTypes = pseudoClassesToArgumentTypes[pseudoClass];
    if (argumentTypes) {
      result[pseudoClass] = calculatePseudoSignature(argumentTypes);
    }
  }
  return result;
}

// node_modules/css-selector-parser/dist/mjs/syntax-definitions.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var emptyXmlOptions = {};
var defaultXmlOptions = { wildcard: true };
function getXmlOptions(param) {
  if (param) {
    if (typeof param === "boolean") {
      return defaultXmlOptions;
    } else {
      return param;
    }
  } else {
    return emptyXmlOptions;
  }
}
function withMigration(migration, merge2) {
  return function(base, extension) {
    return merge2(migration(base), migration(extension));
  };
}
function withNoNegative(merge2) {
  return function(base, extension) {
    var result = merge2(base, extension);
    if (!result) {
      throw new Error("Syntax definition cannot be null or undefined.");
    }
    return result;
  };
}
function withPositive(positive, merge2) {
  return function(base, extension) {
    if (extension === true) {
      return positive;
    }
    return merge2(base === true ? positive : base, extension);
  };
}
function mergeSection(values) {
  return function(base, extension) {
    if (!extension || !base) {
      return extension;
    }
    if (typeof extension !== "object" || extension === null) {
      throw new Error("Unexpected syntax definition extension type: ".concat(extension, "."));
    }
    var result = __assign({}, base);
    for (var _i = 0, _a = Object.entries(extension); _i < _a.length; _i++) {
      var _b = _a[_i], key = _b[0], value = _b[1];
      if (key === "latest") {
        continue;
      }
      var mergeSchema = values[key];
      result[key] = mergeSchema(base[key], value);
    }
    return result;
  };
}
function replaceValueIfSpecified(base, extension) {
  if (extension !== void 0) {
    return extension;
  }
  return base;
}
function concatArray(base, extension) {
  if (!extension) {
    return base;
  }
  if (!base) {
    return extension;
  }
  return base.concat(extension);
}
function mergeDefinitions(base, extension) {
  if (!extension) {
    return base;
  }
  if (!base) {
    return extension;
  }
  var result = __assign({}, base);
  for (var _i = 0, _a = Object.entries(extension); _i < _a.length; _i++) {
    var _b = _a[_i], key = _b[0], value = _b[1];
    if (!value) {
      delete result[key];
      continue;
    }
    var baseValue = base[key];
    if (!baseValue) {
      result[key] = value;
      continue;
    }
    result[key] = baseValue.concat(value);
  }
  return result;
}
var extendSyntaxDefinition = withNoNegative(mergeSection({
  baseSyntax: replaceValueIfSpecified,
  modules: concatArray,
  tag: withPositive(defaultXmlOptions, mergeSection({
    wildcard: replaceValueIfSpecified
  })),
  ids: replaceValueIfSpecified,
  classNames: replaceValueIfSpecified,
  namespace: withPositive(defaultXmlOptions, mergeSection({
    wildcard: replaceValueIfSpecified
  })),
  combinators: concatArray,
  attributes: mergeSection({
    operators: concatArray,
    caseSensitivityModifiers: concatArray,
    unknownCaseSensitivityModifiers: replaceValueIfSpecified
  }),
  pseudoClasses: mergeSection({
    unknown: replaceValueIfSpecified,
    definitions: mergeDefinitions
  }),
  pseudoElements: mergeSection({
    unknown: replaceValueIfSpecified,
    notation: replaceValueIfSpecified,
    definitions: withMigration(function(definitions) {
      return Array.isArray(definitions) ? { NoArgument: definitions } : definitions;
    }, mergeDefinitions)
  })
}));
var css1SyntaxDefinition = {
  tag: {},
  ids: true,
  classNames: true,
  combinators: [],
  pseudoElements: {
    unknown: "reject",
    notation: "singleColon",
    definitions: ["first-letter", "first-line"]
  },
  pseudoClasses: {
    unknown: "reject",
    definitions: {
      NoArgument: ["link", "visited", "active"]
    }
  }
};
var css2SyntaxDefinition = extendSyntaxDefinition(css1SyntaxDefinition, {
  tag: { wildcard: true },
  combinators: [">", "+"],
  attributes: {
    unknownCaseSensitivityModifiers: "reject",
    operators: ["=", "~=", "|="]
  },
  pseudoElements: {
    definitions: ["before", "after"]
  },
  pseudoClasses: {
    unknown: "reject",
    definitions: {
      NoArgument: ["hover", "focus", "first-child"],
      String: ["lang"]
    }
  }
});
var selectors3SyntaxDefinition = extendSyntaxDefinition(css2SyntaxDefinition, {
  namespace: {
    wildcard: true
  },
  combinators: ["~"],
  attributes: {
    operators: ["^=", "$=", "*="]
  },
  pseudoElements: {
    notation: "both"
  },
  pseudoClasses: {
    definitions: {
      NoArgument: [
        "root",
        "last-child",
        "first-of-type",
        "last-of-type",
        "only-child",
        "only-of-type",
        "empty",
        "target",
        "enabled",
        "disabled",
        "checked",
        "indeterminate"
      ],
      Formula: ["nth-child", "nth-last-child", "nth-of-type", "nth-last-of-type"],
      Selector: ["not"]
    }
  }
});
var selectors4SyntaxDefinition = extendSyntaxDefinition(selectors3SyntaxDefinition, {
  combinators: ["||"],
  attributes: {
    caseSensitivityModifiers: ["i", "I", "s", "S"]
  },
  pseudoClasses: {
    definitions: {
      NoArgument: [
        "any-link",
        "local-link",
        "target-within",
        "scope",
        "current",
        "past",
        "future",
        "focus-within",
        "focus-visible",
        "read-write",
        "read-only",
        "placeholder-shown",
        "default",
        "valid",
        "invalid",
        "in-range",
        "out-of-range",
        "required",
        "optional",
        "blank",
        "user-invalid",
        "playing",
        "paused",
        "autofill",
        "modal",
        "fullscreen",
        "picture-in-picture",
        "defined",
        "loading",
        "popover-open"
      ],
      Formula: ["nth-col", "nth-last-col"],
      String: ["dir"],
      FormulaOfSelector: ["nth-child", "nth-last-child"],
      Selector: ["current", "is", "where", "has", "state"]
    }
  },
  pseudoElements: {
    definitions: {
      NoArgument: ["marker"],
      Selector: ["part"]
    }
  }
});
var cssModules = {
  "css-position-1": {
    latest: false,
    pseudoClasses: {
      definitions: {
        NoArgument: ["static", "relative", "absolute"]
      }
    }
  },
  "css-position-2": {
    latest: false,
    pseudoClasses: {
      definitions: {
        NoArgument: ["static", "relative", "absolute", "fixed"]
      }
    }
  },
  "css-position-3": {
    latest: false,
    pseudoClasses: {
      definitions: {
        NoArgument: ["sticky", "fixed", "absolute", "relative", "static"]
      }
    }
  },
  "css-position-4": {
    latest: true,
    pseudoClasses: {
      definitions: {
        NoArgument: ["sticky", "fixed", "absolute", "relative", "static", "initial"]
      }
    }
  },
  "css-scoping-1": {
    latest: true,
    pseudoClasses: {
      definitions: {
        NoArgument: ["host", "host-context"],
        Selector: ["host", "host-context"]
      }
    },
    pseudoElements: {
      definitions: {
        Selector: ["slotted"]
      }
    }
  },
  "css-pseudo-4": {
    latest: true,
    pseudoElements: {
      definitions: {
        NoArgument: [
          "marker",
          "selection",
          "target-text",
          "search-text",
          "spelling-error",
          "grammar-error",
          "backdrop",
          "file-selector-button",
          "prefix",
          "postfix",
          "placeholder",
          "details-content"
        ],
        String: ["highlight"]
      }
    }
  },
  "css-shadow-parts-1": {
    latest: true,
    pseudoElements: {
      definitions: {
        Selector: ["part"]
      }
    }
  }
};
var latestSyntaxDefinition = __assign(__assign({}, selectors4SyntaxDefinition), { modules: Object.entries(cssModules).filter(function(_a) {
  var latest = _a[1].latest;
  return latest;
}).map(function(_a) {
  var name2 = _a[0];
  return name2;
}) });
var progressiveSyntaxDefinition = extendSyntaxDefinition(latestSyntaxDefinition, {
  pseudoElements: {
    unknown: "accept"
  },
  pseudoClasses: {
    unknown: "accept"
  },
  attributes: {
    unknownCaseSensitivityModifiers: "accept"
  }
});
var cssSyntaxDefinitions = {
  css1: css1SyntaxDefinition,
  css2: css2SyntaxDefinition,
  css3: selectors3SyntaxDefinition,
  "selectors-3": selectors3SyntaxDefinition,
  "selectors-4": selectors4SyntaxDefinition,
  latest: latestSyntaxDefinition,
  progressive: progressiveSyntaxDefinition
};
function buildPseudoLocationIndex() {
  var index = {
    pseudoClasses: {},
    pseudoElements: {}
  };
  var cssLevels = ["css1", "css2", "css3", "selectors-3", "selectors-4"];
  for (var _i = 0, cssLevels_1 = cssLevels; _i < cssLevels_1.length; _i++) {
    var level = cssLevels_1[_i];
    var syntax = cssSyntaxDefinitions[level];
    if (syntax.pseudoClasses && typeof syntax.pseudoClasses === "object") {
      var definitions = syntax.pseudoClasses.definitions;
      if (definitions) {
        for (var _a = 0, _b = Object.entries(definitions); _a < _b.length; _a++) {
          var _c = _b[_a], names = _c[1];
          for (var _d = 0, names_1 = names; _d < names_1.length; _d++) {
            var name_1 = names_1[_d];
            if (!index.pseudoClasses[name_1]) {
              index.pseudoClasses[name_1] = [];
            }
            if (!index.pseudoClasses[name_1].includes(level)) {
              index.pseudoClasses[name_1].push(level);
            }
          }
        }
      }
    }
    if (syntax.pseudoElements && typeof syntax.pseudoElements === "object") {
      var definitions = syntax.pseudoElements.definitions;
      if (definitions) {
        if (Array.isArray(definitions)) {
          for (var _e = 0, definitions_1 = definitions; _e < definitions_1.length; _e++) {
            var name_2 = definitions_1[_e];
            if (!index.pseudoElements[name_2]) {
              index.pseudoElements[name_2] = [];
            }
            if (!index.pseudoElements[name_2].includes(level)) {
              index.pseudoElements[name_2].push(level);
            }
          }
        } else {
          for (var _f = 0, _g = Object.values(definitions); _f < _g.length; _f++) {
            var names = _g[_f];
            for (var _h = 0, names_2 = names; _h < names_2.length; _h++) {
              var name_3 = names_2[_h];
              if (!index.pseudoElements[name_3]) {
                index.pseudoElements[name_3] = [];
              }
              if (!index.pseudoElements[name_3].includes(level)) {
                index.pseudoElements[name_3].push(level);
              }
            }
          }
        }
      }
    }
  }
  for (var _j = 0, _k = Object.entries(cssModules); _j < _k.length; _j++) {
    var _l = _k[_j], moduleName = _l[0], moduleSyntax = _l[1];
    if (moduleSyntax.pseudoClasses && typeof moduleSyntax.pseudoClasses === "object") {
      var definitions = moduleSyntax.pseudoClasses.definitions;
      if (definitions) {
        for (var _m = 0, _o = Object.values(definitions); _m < _o.length; _m++) {
          var names = _o[_m];
          for (var _p = 0, names_3 = names; _p < names_3.length; _p++) {
            var name_4 = names_3[_p];
            if (!index.pseudoClasses[name_4]) {
              index.pseudoClasses[name_4] = [];
            }
            if (!index.pseudoClasses[name_4].includes(moduleName)) {
              index.pseudoClasses[name_4].push(moduleName);
            }
          }
        }
      }
    }
    if (moduleSyntax.pseudoElements && typeof moduleSyntax.pseudoElements === "object") {
      var definitions = moduleSyntax.pseudoElements.definitions;
      if (definitions) {
        if (Array.isArray(definitions)) {
          for (var _q = 0, definitions_2 = definitions; _q < definitions_2.length; _q++) {
            var name_5 = definitions_2[_q];
            if (!index.pseudoElements[name_5]) {
              index.pseudoElements[name_5] = [];
            }
            if (!index.pseudoElements[name_5].includes(moduleName)) {
              index.pseudoElements[name_5].push(moduleName);
            }
          }
        } else {
          for (var _r = 0, _s = Object.values(definitions); _r < _s.length; _r++) {
            var names = _s[_r];
            for (var _t = 0, names_4 = names; _t < names_4.length; _t++) {
              var name_6 = names_4[_t];
              if (!index.pseudoElements[name_6]) {
                index.pseudoElements[name_6] = [];
              }
              if (!index.pseudoElements[name_6].includes(moduleName)) {
                index.pseudoElements[name_6].push(moduleName);
              }
            }
          }
        }
      }
    }
  }
  return index;
}
var pseudoLocationIndex = buildPseudoLocationIndex();

// node_modules/css-selector-parser/dist/mjs/utils.js
function isIdentStart(c) {
  return c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c === "-" || c === "_" || c === "\\" || c >= " ";
}
function isIdent(c) {
  return c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c >= "0" && c <= "9" || c === "-" || c === "_" || c >= " ";
}
function isHex(c) {
  return c >= "a" && c <= "f" || c >= "A" && c <= "F" || c >= "0" && c <= "9";
}
var whitespaceChars = {
  " ": true,
  "	": true,
  "\n": true,
  "\r": true,
  "\f": true
};
var quoteChars = {
  '"': true,
  "'": true
};
var digitsChars = {
  0: true,
  1: true,
  2: true,
  3: true,
  4: true,
  5: true,
  6: true,
  7: true,
  8: true,
  9: true
};
var maxHexLength = 6;

// node_modules/css-selector-parser/dist/mjs/parser.js
var errorPrefix = "css-selector-parser parse error: ";
function createParser(options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.syntax, syntax = _a === void 0 ? "latest" : _a, substitutes = options.substitutes, _b = options.strict, strict = _b === void 0 ? true : _b, modules = options.modules;
  var syntaxDefinition = typeof syntax === "object" ? syntax : cssSyntaxDefinitions[syntax];
  if (syntaxDefinition.baseSyntax) {
    syntaxDefinition = extendSyntaxDefinition(cssSyntaxDefinitions[syntaxDefinition.baseSyntax], syntaxDefinition);
  }
  if (syntaxDefinition.modules && syntaxDefinition.modules.length > 0) {
    for (var _i = 0, _c = syntaxDefinition.modules; _i < _c.length; _i++) {
      var module_1 = _c[_i];
      var moduleSyntax = cssModules[module_1];
      if (moduleSyntax) {
        syntaxDefinition = extendSyntaxDefinition(moduleSyntax, syntaxDefinition);
      }
    }
  }
  if (modules && modules.length > 0) {
    for (var _d = 0, modules_1 = modules; _d < modules_1.length; _d++) {
      var module_2 = modules_1[_d];
      var moduleSyntax = cssModules[module_2];
      if (moduleSyntax) {
        syntaxDefinition = extendSyntaxDefinition(moduleSyntax, syntaxDefinition);
      }
    }
  }
  var _e = syntaxDefinition.tag ? [true, Boolean(getXmlOptions(syntaxDefinition.tag).wildcard)] : [false, false], tagNameEnabled = _e[0], tagNameWildcardEnabled = _e[1];
  var idEnabled = Boolean(syntaxDefinition.ids);
  var classNamesEnabled = Boolean(syntaxDefinition.classNames);
  var namespaceEnabled = Boolean(syntaxDefinition.namespace);
  var namespaceWildcardEnabled = syntaxDefinition.namespace && (syntaxDefinition.namespace === true || syntaxDefinition.namespace.wildcard === true);
  if (namespaceEnabled && !tagNameEnabled) {
    throw new Error("".concat(errorPrefix, "Namespaces cannot be enabled while tags are disabled."));
  }
  var substitutesEnabled = Boolean(substitutes);
  var combinatorsIndex = syntaxDefinition.combinators ? createMulticharIndex(syntaxDefinition.combinators) : emptyMulticharIndex;
  var _f = syntaxDefinition.attributes ? [
    true,
    syntaxDefinition.attributes.operators ? createMulticharIndex(syntaxDefinition.attributes.operators) : emptyMulticharIndex,
    syntaxDefinition.attributes.caseSensitivityModifiers ? createRegularIndex(syntaxDefinition.attributes.caseSensitivityModifiers) : emptyRegularIndex,
    syntaxDefinition.attributes.unknownCaseSensitivityModifiers === "accept"
  ] : [false, emptyMulticharIndex, emptyRegularIndex, false], attributesEnabled = _f[0], attributesOperatorsIndex = _f[1], attributesCaseSensitivityModifiers = _f[2], attributesAcceptUnknownCaseSensitivityModifiers = _f[3];
  var attributesCaseSensitivityModifiersEnabled = attributesAcceptUnknownCaseSensitivityModifiers || Object.keys(attributesCaseSensitivityModifiers).length > 0;
  var _g = syntaxDefinition.pseudoClasses ? [
    true,
    syntaxDefinition.pseudoClasses.definitions ? calculatePseudoSignatures(syntaxDefinition.pseudoClasses.definitions) : emptyPseudoSignatures,
    syntaxDefinition.pseudoClasses.unknown === "accept"
  ] : [false, emptyPseudoSignatures, false], pseudoClassesEnabled = _g[0], pseudoClassesDefinitions = _g[1], pseudoClassesAcceptUnknown = _g[2];
  var _h = syntaxDefinition.pseudoElements ? [
    true,
    syntaxDefinition.pseudoElements.notation === "singleColon" || syntaxDefinition.pseudoElements.notation === "both",
    !syntaxDefinition.pseudoElements.notation || syntaxDefinition.pseudoElements.notation === "doubleColon" || syntaxDefinition.pseudoElements.notation === "both",
    syntaxDefinition.pseudoElements.definitions ? calculatePseudoSignatures(Array.isArray(syntaxDefinition.pseudoElements.definitions) ? { NoArgument: syntaxDefinition.pseudoElements.definitions } : syntaxDefinition.pseudoElements.definitions) : emptyPseudoSignatures,
    syntaxDefinition.pseudoElements.unknown === "accept"
  ] : [false, false, false, emptyPseudoSignatures, false], pseudoElementsEnabled = _h[0], pseudoElementsSingleColonNotationEnabled = _h[1], pseudoElementsDoubleColonNotationEnabled = _h[2], pseudoElementsDefinitions = _h[3], pseudoElementsAcceptUnknown = _h[4];
  var str = "";
  var l = str.length;
  var pos = 0;
  var chr = "";
  var is3 = function(comparison) {
    return chr === comparison;
  };
  var isTagStart = function() {
    return is3("*") || isIdentStart(chr);
  };
  var rewind = function(newPos) {
    pos = newPos;
    chr = str.charAt(pos);
  };
  var next = function() {
    pos++;
    chr = str.charAt(pos);
  };
  var readAndNext = function() {
    var current = chr;
    pos++;
    chr = str.charAt(pos);
    return current;
  };
  function fail(errorMessage) {
    var position = Math.min(l - 1, pos);
    var error = new Error("".concat(errorPrefix).concat(errorMessage, " Pos: ").concat(position, "."));
    error.position = position;
    error.name = "ParserError";
    throw error;
  }
  function assert2(condition, errorMessage) {
    if (!condition) {
      return fail(errorMessage);
    }
  }
  var assertNonEof = function() {
    assert2(pos < l, "Unexpected end of input.");
  };
  var isEof = function() {
    return pos >= l;
  };
  var pass = function(character) {
    assert2(pos < l, 'Expected "'.concat(character, '" but end of input reached.'));
    assert2(chr === character, 'Expected "'.concat(character, '" but "').concat(chr, '" found.'));
    pos++;
    chr = str.charAt(pos);
  };
  function matchMulticharIndex(index) {
    var match = matchMulticharIndexPos(index, pos);
    if (match) {
      pos += match.length;
      chr = str.charAt(pos);
      return match;
    }
  }
  function matchMulticharIndexPos(index, subPos) {
    var char = str.charAt(subPos);
    var charIndex = index[char];
    if (charIndex) {
      var subMatch = matchMulticharIndexPos(charIndex.chars, subPos + 1);
      if (subMatch) {
        return subMatch;
      }
      if (charIndex.self) {
        return charIndex.self;
      }
    }
  }
  function parseHex() {
    var hex = readAndNext();
    var count2 = 1;
    while (isHex(chr) && count2 < maxHexLength) {
      hex += readAndNext();
      count2++;
    }
    skipSingleWhitespace();
    return String.fromCharCode(parseInt(hex, 16));
  }
  function parseString(quote) {
    var result = "";
    pass(quote);
    while (pos < l) {
      if (is3(quote)) {
        next();
        return result;
      } else if (is3("\\")) {
        next();
        if (is3(quote)) {
          result += quote;
          next();
        } else if (chr === "\n" || chr === "\f") {
          next();
        } else if (chr === "\r") {
          next();
          if (is3("\n")) {
            next();
          }
        } else if (isHex(chr)) {
          result += parseHex();
        } else {
          result += chr;
          next();
        }
      } else {
        result += chr;
        next();
      }
    }
    return result;
  }
  function parseIdentifier() {
    if (!isIdentStart(chr)) {
      return null;
    }
    var result = "";
    while (is3("-")) {
      result += chr;
      next();
    }
    if (result === "-" && !isIdent(chr) && !is3("\\")) {
      fail("Identifiers cannot consist of a single hyphen.");
    }
    if (strict && result.length >= 2) {
      fail("Identifiers cannot start with two hyphens with strict mode on.");
    }
    if (digitsChars[chr]) {
      fail("Identifiers cannot start with hyphens followed by digits.");
    }
    while (pos < l) {
      if (isIdent(chr)) {
        result += readAndNext();
      } else if (is3("\\")) {
        next();
        assertNonEof();
        if (isHex(chr)) {
          result += parseHex();
        } else {
          result += readAndNext();
        }
      } else {
        break;
      }
    }
    return result;
  }
  function parsePseudoClassString() {
    var result = "";
    while (pos < l) {
      if (is3(")")) {
        break;
      } else if (is3("\\")) {
        next();
        if (isEof() && !strict) {
          return (result + "\\").trim();
        }
        assertNonEof();
        if (isHex(chr)) {
          result += parseHex();
        } else {
          result += readAndNext();
        }
      } else {
        result += readAndNext();
      }
    }
    return result.trim();
  }
  function skipSingleWhitespace() {
    if (chr === " " || chr === "	" || chr === "\f" || chr === "\n") {
      next();
      return;
    }
    if (chr === "\r") {
      next();
    }
    if (chr === "\n") {
      next();
    }
  }
  function skipWhitespace() {
    while (whitespaceChars[chr]) {
      next();
    }
  }
  function parseSelector(relative) {
    if (relative === void 0) {
      relative = false;
    }
    skipWhitespace();
    var rules = [parseRule(relative)];
    while (is3(",")) {
      next();
      skipWhitespace();
      rules.push(parseRule(relative));
    }
    return {
      type: "Selector",
      rules
    };
  }
  function parseAttribute() {
    pass("[");
    skipWhitespace();
    var attr;
    if (is3("|")) {
      assert2(namespaceEnabled, "Namespaces are not enabled.");
      next();
      var name_1 = parseIdentifier();
      assert2(name_1, "Expected attribute name.");
      attr = {
        type: "Attribute",
        name: name_1,
        namespace: { type: "NoNamespace" }
      };
    } else if (is3("*")) {
      assert2(namespaceEnabled, "Namespaces are not enabled.");
      assert2(namespaceWildcardEnabled, "Wildcard namespace is not enabled.");
      next();
      pass("|");
      var name_2 = parseIdentifier();
      assert2(name_2, "Expected attribute name.");
      attr = {
        type: "Attribute",
        name: name_2,
        namespace: { type: "WildcardNamespace" }
      };
    } else {
      var identifier = parseIdentifier();
      assert2(identifier, "Expected attribute name.");
      attr = {
        type: "Attribute",
        name: identifier
      };
      if (is3("|")) {
        var savedPos = pos;
        next();
        if (isIdentStart(chr)) {
          assert2(namespaceEnabled, "Namespaces are not enabled.");
          var name_3 = parseIdentifier();
          assert2(name_3, "Expected attribute name.");
          attr = {
            type: "Attribute",
            name: name_3,
            namespace: { type: "NamespaceName", name: identifier }
          };
        } else {
          rewind(savedPos);
        }
      }
    }
    assert2(attr.name, "Expected attribute name.");
    skipWhitespace();
    if (isEof() && !strict) {
      return attr;
    }
    if (is3("]")) {
      next();
    } else {
      attr.operator = matchMulticharIndex(attributesOperatorsIndex);
      assert2(attr.operator, "Expected a valid attribute selector operator.");
      skipWhitespace();
      assertNonEof();
      if (quoteChars[chr]) {
        attr.value = {
          type: "String",
          value: parseString(chr)
        };
      } else if (substitutesEnabled && is3("$")) {
        next();
        var name_4 = parseIdentifier();
        assert2(name_4, "Expected substitute name.");
        attr.value = {
          type: "Substitution",
          name: name_4
        };
      } else {
        var value = parseIdentifier();
        assert2(value, "Expected attribute value.");
        attr.value = {
          type: "String",
          value
        };
      }
      skipWhitespace();
      if (isEof() && !strict) {
        return attr;
      }
      if (!is3("]")) {
        var caseSensitivityModifier = parseIdentifier();
        assert2(caseSensitivityModifier, "Expected end of attribute selector.");
        attr.caseSensitivityModifier = caseSensitivityModifier;
        assert2(attributesCaseSensitivityModifiersEnabled, "Attribute case sensitivity modifiers are not enabled.");
        assert2(attributesAcceptUnknownCaseSensitivityModifiers || attributesCaseSensitivityModifiers[attr.caseSensitivityModifier], "Unknown attribute case sensitivity modifier.");
        skipWhitespace();
        if (isEof() && !strict) {
          return attr;
        }
      }
      pass("]");
    }
    return attr;
  }
  function parseNumber() {
    var result = "";
    while (digitsChars[chr]) {
      result += readAndNext();
    }
    assert2(result !== "", "Formula parse error.");
    return parseInt(result);
  }
  var isNumberStart = function() {
    return is3("-") || is3("+") || digitsChars[chr];
  };
  function parseFormula() {
    if (is3("e") || is3("o")) {
      var ident = parseIdentifier();
      if (ident === "even") {
        skipWhitespace();
        return [2, 0];
      }
      if (ident === "odd") {
        skipWhitespace();
        return [2, 1];
      }
    }
    var firstNumber = null;
    var firstNumberMultiplier = 1;
    if (is3("-")) {
      next();
      firstNumberMultiplier = -1;
    }
    if (isNumberStart()) {
      if (is3("+")) {
        next();
      }
      firstNumber = parseNumber();
      if (!is3("\\") && !is3("n")) {
        return [0, firstNumber * firstNumberMultiplier];
      }
    }
    if (firstNumber === null) {
      firstNumber = 1;
    }
    firstNumber *= firstNumberMultiplier;
    var identifier;
    if (is3("\\")) {
      next();
      if (isHex(chr)) {
        identifier = parseHex();
      } else {
        identifier = readAndNext();
      }
    } else {
      identifier = readAndNext();
    }
    assert2(identifier === "n", 'Formula parse error: expected "n".');
    skipWhitespace();
    if (is3("+") || is3("-")) {
      var sign = is3("+") ? 1 : -1;
      next();
      skipWhitespace();
      return [firstNumber, sign * parseNumber()];
    } else {
      return [firstNumber, 0];
    }
  }
  function parsePseudoArgument(pseudoName, type, signature) {
    var argument;
    if (is3("(")) {
      next();
      skipWhitespace();
      if (substitutesEnabled && is3("$")) {
        next();
        var name_5 = parseIdentifier();
        assert2(name_5, "Expected substitute name.");
        argument = {
          type: "Substitution",
          name: name_5
        };
      } else if (signature.type === "String") {
        argument = {
          type: "String",
          value: parsePseudoClassString()
        };
        assert2(argument.value, "Expected ".concat(type, " argument value."));
      } else if (signature.type === "Selector") {
        argument = parseSelector(true);
      } else if (signature.type === "Formula") {
        var _a2 = parseFormula(), a = _a2[0], b = _a2[1];
        argument = {
          type: "Formula",
          a,
          b
        };
        if (signature.ofSelector) {
          skipWhitespace();
          if (is3("o") || is3("\\")) {
            var ident = parseIdentifier();
            assert2(ident === "of", "Formula of selector parse error.");
            skipWhitespace();
            argument = {
              type: "FormulaOfSelector",
              a,
              b,
              selector: parseRule()
            };
          }
        }
      } else {
        return fail("Invalid ".concat(type, " signature."));
      }
      skipWhitespace();
      if (isEof() && !strict) {
        return argument;
      }
      pass(")");
    } else {
      assert2(signature.optional, "Argument is required for ".concat(type, ' "').concat(pseudoName, '".'));
    }
    return argument;
  }
  function parseTagName() {
    if (is3("*")) {
      assert2(tagNameWildcardEnabled, "Wildcard tag name is not enabled.");
      next();
      return { type: "WildcardTag" };
    } else if (isIdentStart(chr)) {
      assert2(tagNameEnabled, "Tag names are not enabled.");
      var name_6 = parseIdentifier();
      assert2(name_6, "Expected tag name.");
      return {
        type: "TagName",
        name: name_6
      };
    } else {
      return fail("Expected tag name.");
    }
  }
  function parseTagNameWithNamespace() {
    if (is3("*")) {
      var savedPos = pos;
      next();
      if (!is3("|")) {
        rewind(savedPos);
        return parseTagName();
      }
      next();
      if (!isTagStart()) {
        rewind(savedPos);
        return parseTagName();
      }
      assert2(namespaceEnabled, "Namespaces are not enabled.");
      assert2(namespaceWildcardEnabled, "Wildcard namespace is not enabled.");
      var tagName = parseTagName();
      tagName.namespace = { type: "WildcardNamespace" };
      return tagName;
    } else if (is3("|")) {
      assert2(namespaceEnabled, "Namespaces are not enabled.");
      next();
      var tagName = parseTagName();
      tagName.namespace = { type: "NoNamespace" };
      return tagName;
    } else if (isIdentStart(chr)) {
      var identifier = parseIdentifier();
      assert2(identifier, "Expected tag name.");
      if (!is3("|")) {
        assert2(tagNameEnabled, "Tag names are not enabled.");
        return {
          type: "TagName",
          name: identifier
        };
      }
      var savedPos = pos;
      next();
      if (!isTagStart()) {
        rewind(savedPos);
        return {
          type: "TagName",
          name: identifier
        };
      }
      assert2(namespaceEnabled, "Namespaces are not enabled.");
      var tagName = parseTagName();
      tagName.namespace = { type: "NamespaceName", name: identifier };
      return tagName;
    } else {
      return fail("Expected tag name.");
    }
  }
  function parseRule(relative) {
    var _a2, _b2;
    if (relative === void 0) {
      relative = false;
    }
    var rule = { type: "Rule", items: [] };
    if (relative) {
      var combinator = matchMulticharIndex(combinatorsIndex);
      if (combinator) {
        rule.combinator = combinator;
        skipWhitespace();
      }
    }
    while (pos < l) {
      if (isTagStart()) {
        assert2(rule.items.length === 0, "Unexpected tag/namespace start.");
        rule.items.push(parseTagNameWithNamespace());
      } else if (is3("|")) {
        var savedPos = pos;
        next();
        if (isTagStart()) {
          assert2(rule.items.length === 0, "Unexpected tag/namespace start.");
          rewind(savedPos);
          rule.items.push(parseTagNameWithNamespace());
        } else {
          rewind(savedPos);
          break;
        }
      } else if (is3(".")) {
        assert2(classNamesEnabled, "Class names are not enabled.");
        next();
        var className2 = parseIdentifier();
        assert2(className2, "Expected class name.");
        rule.items.push({ type: "ClassName", name: className2 });
      } else if (is3("#")) {
        assert2(idEnabled, "IDs are not enabled.");
        next();
        var idName = parseIdentifier();
        assert2(idName, "Expected ID name.");
        rule.items.push({ type: "Id", name: idName });
      } else if (is3("[")) {
        assert2(attributesEnabled, "Attributes are not enabled.");
        rule.items.push(parseAttribute());
      } else if (is3(":")) {
        var isDoubleColon = false;
        var isPseudoElement = false;
        next();
        if (is3(":")) {
          assert2(pseudoElementsEnabled, "Pseudo elements are not enabled.");
          assert2(pseudoElementsDoubleColonNotationEnabled, "Pseudo elements double colon notation is not enabled.");
          isDoubleColon = true;
          next();
        }
        var pseudoName = parseIdentifier();
        assert2(isDoubleColon || pseudoName, "Expected pseudo-class name.");
        assert2(!isDoubleColon || pseudoName, "Expected pseudo-element name.");
        assert2(pseudoName, "Expected pseudo-class name.");
        if (!isDoubleColon || pseudoElementsAcceptUnknown || Object.prototype.hasOwnProperty.call(pseudoElementsDefinitions, pseudoName)) {
        } else {
          var locations = pseudoLocationIndex.pseudoElements[pseudoName];
          var errorMessage = 'Unknown pseudo-element "'.concat(pseudoName, '"');
          if (locations && locations.length > 0) {
            errorMessage += ". It is defined in: ".concat(locations.join(", "));
          }
          fail(errorMessage + ".");
        }
        isPseudoElement = pseudoElementsEnabled && (isDoubleColon || !isDoubleColon && pseudoElementsSingleColonNotationEnabled && Object.prototype.hasOwnProperty.call(pseudoElementsDefinitions, pseudoName));
        if (isPseudoElement) {
          var signature = (_a2 = pseudoElementsDefinitions[pseudoName]) !== null && _a2 !== void 0 ? _a2 : pseudoElementsAcceptUnknown && defaultPseudoSignature;
          var pseudoElement = {
            type: "PseudoElement",
            name: pseudoName
          };
          var argument = parsePseudoArgument(pseudoName, "pseudo-element", signature);
          if (argument) {
            assert2(argument.type !== "Formula" && argument.type !== "FormulaOfSelector", "Pseudo-elements cannot have formula argument.");
            pseudoElement.argument = argument;
          }
          rule.items.push(pseudoElement);
        } else {
          assert2(pseudoClassesEnabled, "Pseudo-classes are not enabled.");
          var signature = (_b2 = pseudoClassesDefinitions[pseudoName]) !== null && _b2 !== void 0 ? _b2 : pseudoClassesAcceptUnknown && defaultPseudoSignature;
          if (signature) {
          } else {
            var locations = pseudoLocationIndex.pseudoClasses[pseudoName];
            var errorMessage = 'Unknown pseudo-class: "'.concat(pseudoName, '"');
            if (locations && locations.length > 0) {
              errorMessage += ". It is defined in: ".concat(locations.join(", "));
            }
            fail(errorMessage + ".");
          }
          var argument = parsePseudoArgument(pseudoName, "pseudo-class", signature);
          var pseudoClass = {
            type: "PseudoClass",
            name: pseudoName
          };
          if (argument) {
            pseudoClass.argument = argument;
          }
          rule.items.push(pseudoClass);
        }
      } else {
        break;
      }
    }
    if (rule.items.length === 0) {
      if (isEof()) {
        return fail("Expected rule but end of input reached.");
      } else {
        return fail('Expected rule but "'.concat(chr, '" found.'));
      }
    }
    skipWhitespace();
    if (!isEof() && !is3(",") && !is3(")")) {
      var combinator = matchMulticharIndex(combinatorsIndex);
      skipWhitespace();
      rule.nestedRule = parseRule();
      rule.nestedRule.combinator = combinator;
    }
    return rule;
  }
  return function(input) {
    if (typeof input !== "string") {
      throw new Error("".concat(errorPrefix, "Expected string input."));
    }
    str = input;
    l = str.length;
    pos = 0;
    chr = str.charAt(0);
    return parseSelector();
  };
}

// node_modules/css-selector-parser/dist/mjs/ast.js
var __assign2 = function() {
  __assign2 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
function astMethods(type) {
  return function(generatorName, checkerName) {
    var _a;
    return _a = {}, _a[generatorName] = function(props) {
      return __assign2({ type }, props);
    }, _a[checkerName] = function(entity) {
      return typeof entity === "object" && entity !== null && entity.type === type;
    }, _a;
  };
}
var ast = __assign2(__assign2(__assign2(__assign2(__assign2(__assign2(__assign2(__assign2(__assign2(__assign2(__assign2(__assign2(__assign2(__assign2(__assign2(__assign2({}, astMethods("Selector")("selector", "isSelector")), astMethods("Rule")("rule", "isRule")), astMethods("TagName")("tagName", "isTagName")), astMethods("Id")("id", "isId")), astMethods("ClassName")("className", "isClassName")), astMethods("WildcardTag")("wildcardTag", "isWildcardTag")), astMethods("NamespaceName")("namespaceName", "isNamespaceName")), astMethods("WildcardNamespace")("wildcardNamespace", "isWildcardNamespace")), astMethods("NoNamespace")("noNamespace", "isNoNamespace")), astMethods("Attribute")("attribute", "isAttribute")), astMethods("PseudoClass")("pseudoClass", "isPseudoClass")), astMethods("PseudoElement")("pseudoElement", "isPseudoElement")), astMethods("String")("string", "isString")), astMethods("Formula")("formula", "isFormula")), astMethods("FormulaOfSelector")("formulaOfSelector", "isFormulaOfSelector")), astMethods("Substitution")("substitution", "isSubstitution"));

// node_modules/hast-util-select/lib/parse.js
var cssSelectorParse = createParser({ syntax: "selectors-4" });
function parse(selector) {
  if (typeof selector !== "string") {
    throw new TypeError("Expected `string` as selector, not `" + selector + "`");
  }
  return cssSelectorParse(selector);
}

// node_modules/direction/index.js
var rtlRange = "֑-߿יִ-﷽ﹰ-ﻼ";
var ltrRange = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿";
var rtl = new RegExp("^[^" + ltrRange + "]*[" + rtlRange + "]");
var ltr = new RegExp("^[^" + rtlRange + "]*[" + ltrRange + "]");
function direction(value) {
  const source = String(value || "");
  return rtl.test(source) ? "rtl" : ltr.test(source) ? "ltr" : "neutral";
}

// node_modules/hast-util-to-string/lib/index.js
function toString(node) {
  if ("children" in node) {
    return all(node);
  }
  return "value" in node ? node.value : "";
}
function one(node) {
  if (node.type === "text") {
    return node.value;
  }
  return "children" in node ? all(node) : "";
}
function all(node) {
  let index = -1;
  const result = [];
  while (++index < node.children.length) {
    result[index] = one(node.children[index]);
  }
  return result.join("");
}

// node_modules/hast-util-select/lib/enter-state.js
function enterState(state, node) {
  const schema = state.schema;
  const language = state.language;
  const currentDirection = state.direction;
  const editableOrEditingHost = state.editableOrEditingHost;
  let directionInferred;
  if (node.type === "element") {
    const lang2 = node.properties.xmlLang || node.properties.lang;
    const type = node.properties.type || "text";
    const direction2 = directionProperty(node);
    if (lang2 !== null && lang2 !== void 0) {
      state.language = String(lang2);
    }
    if (schema && schema.space === "html") {
      if (node.properties.contentEditable === "true") {
        state.editableOrEditingHost = true;
      }
      if (node.tagName === "svg") {
        state.schema = svg2;
      }
      if (direction2 === "rtl") {
        directionInferred = direction2;
      } else if (
        // Explicit `[dir=ltr]`.
        direction2 === "ltr" || // HTML with an invalid or no `[dir]`.
        direction2 !== "auto" && node.tagName === "html" || // `input[type=tel]` with an invalid or no `[dir]`.
        direction2 !== "auto" && node.tagName === "input" && type === "tel"
      ) {
        directionInferred = "ltr";
      } else if (direction2 === "auto" || node.tagName === "bdi") {
        if (node.tagName === "textarea") {
          directionInferred = directionBidi(toString(node));
        } else if (node.tagName === "input" && (type === "email" || type === "search" || type === "tel" || type === "text")) {
          directionInferred = node.properties.value ? directionBidi(String(node.properties.value)) : "ltr";
        } else {
          visit(node, inferDirectionality);
        }
      }
      if (directionInferred) {
        state.direction = directionInferred;
      }
    } else if (state.editableOrEditingHost) {
      state.editableOrEditingHost = false;
    }
  }
  return reset;
  function reset() {
    state.schema = schema;
    state.language = language;
    state.direction = currentDirection;
    state.editableOrEditingHost = editableOrEditingHost;
  }
  function inferDirectionality(child) {
    if (child.type === "text") {
      directionInferred = directionBidi(child.value);
      return directionInferred ? EXIT : void 0;
    }
    if (child !== node && child.type === "element" && (child.tagName === "bdi" || child.tagName === "script" || child.tagName === "style" || child.tagName === "textare" || directionProperty(child))) {
      return SKIP;
    }
  }
}
function directionBidi(value) {
  const result = direction(value);
  return result === "neutral" ? void 0 : result;
}
function directionProperty(node) {
  const value = node.type === "element" && typeof node.properties.dir === "string" ? node.properties.dir.toLowerCase() : void 0;
  return value === "auto" || value === "ltr" || value === "rtl" ? value : void 0;
}

// node_modules/comma-separated-tokens/index.js
function parse2(value) {
  const tokens = [];
  const input = String(value || "");
  let index = input.indexOf(",");
  let start = 0;
  let end = false;
  while (!end) {
    if (index === -1) {
      index = input.length;
      end = true;
    }
    const token = input.slice(start, index).trim();
    if (token || !end) {
      tokens.push(token);
    }
    start = index + 1;
    index = input.indexOf(",", start);
  }
  return tokens;
}
function stringify(values, options) {
  const settings = options || {};
  const input = values[values.length - 1] === "" ? [...values, ""] : values;
  return input.join(
    (settings.padRight ? " " : "") + "," + (settings.padLeft === false ? "" : " ")
  ).trim();
}

// node_modules/devlop/lib/development.js
var AssertionError = class extends Error {
  /**
   * Create an assertion error.
   *
   * @param {string} message
   *   Message explaining error.
   * @param {unknown} actual
   *   Value.
   * @param {unknown} expected
   *   Baseline.
   * @param {string} operator
   *   Name of equality operation.
   * @param {boolean} generated
   *   Whether `message` is a custom message or not
   * @returns
   *   Instance.
   */
  // eslint-disable-next-line max-params
  constructor(message, actual, expected, operator, generated) {
    super(message);
    __publicField(
      this,
      "name",
      /** @type {const} */
      "Assertion"
    );
    __publicField(
      this,
      "code",
      /** @type {const} */
      "ERR_ASSERTION"
    );
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.actual = actual;
    this.expected = expected;
    this.generated = generated;
    this.operator = operator;
  }
};
function ok2(value, message) {
  assert(
    Boolean(value),
    false,
    true,
    "ok",
    "Expected value to be truthy",
    message
  );
}
function unreachable(message) {
  assert(false, false, true, "ok", "Unreachable", message);
}
function assert(bool, actual, expected, operator, defaultMessage, userMessage) {
  if (!bool) {
    throw userMessage instanceof Error ? userMessage : new AssertionError(
      userMessage || defaultMessage,
      actual,
      expected,
      operator,
      !userMessage
    );
  }
}

// node_modules/space-separated-tokens/index.js
function parse3(value) {
  const input = String(value || "").trim();
  return input ? input.split(/[ \t\n\r\f]+/g) : [];
}
function stringify2(values) {
  return values.join(" ").trim();
}

// node_modules/hast-util-select/lib/attribute.js
function attribute(query, element, schema) {
  const info = find(schema, query.name);
  const propertyValue = element.properties[info.property];
  let value = normalizeValue(propertyValue, info);
  if (!query.value) {
    return value !== void 0;
  }
  ok2(query.value.type === "String", "expected plain string");
  let key = query.value.value;
  if (query.caseSensitivityModifier === "i") {
    key = key.toLowerCase();
    if (value) {
      value = value.toLowerCase();
    }
  }
  if (value !== void 0) {
    switch (query.operator) {
      case "=": {
        return key === value;
      }
      case "$=": {
        return key === value.slice(-key.length);
      }
      case "*=": {
        return value.includes(key);
      }
      case "^=": {
        return key === value.slice(0, key.length);
      }
      case "|=": {
        return key === value || key === value.slice(0, key.length) && value.charAt(key.length) === "-";
      }
      case "~=": {
        return (
          // For all other values (including comma-separated lists), return whether this
          // is an exact match.
          key === value || // If this is a space-separated list, and the query is contained in it, return
          // true.
          parse3(value).includes(key)
        );
      }
    }
  }
  return false;
}
function normalizeValue(value, info) {
  if (value === null || value === void 0) {
  } else if (typeof value === "boolean") {
    if (value) {
      return info.attribute;
    }
  } else if (Array.isArray(value)) {
    if (value.length > 0) {
      return (info.commaSeparated ? stringify : stringify2)(value);
    }
  } else {
    return String(value);
  }
}

// node_modules/hast-util-select/lib/class-name.js
var emptyClassNames = [];
function className(query, element) {
  const value = (
    /** @type {Readonly<Array<string>>} */
    element.properties.className || emptyClassNames
  );
  return value.includes(query.name);
}

// node_modules/hast-util-select/lib/id.js
function id(query, element) {
  return element.properties.id === query.name;
}

// node_modules/hast-util-select/lib/name.js
function name(query, element) {
  return query.name === element.tagName;
}

// node_modules/bcp-47-match/index.js
function factory(check, filter) {
  return function(tags, ranges) {
    let left = cast(tags, "tag");
    const right = cast(
      ranges === null || ranges === void 0 ? "*" : ranges,
      "range"
    );
    const matches2 = [];
    let rightIndex = -1;
    while (++rightIndex < right.length) {
      const range = right[rightIndex].toLowerCase();
      if (!filter && range === "*") continue;
      let leftIndex = -1;
      const next = [];
      while (++leftIndex < left.length) {
        if (check(left[leftIndex].toLowerCase(), range)) {
          if (!filter) {
            return (
              /** @type {IsFilter extends true ? Tags : Tag|undefined} */
              left[leftIndex]
            );
          }
          matches2.push(left[leftIndex]);
        } else {
          next.push(left[leftIndex]);
        }
      }
      left = next;
    }
    return (
      /** @type {IsFilter extends true ? Tags : Tag|undefined} */
      filter ? matches2 : void 0
    );
  };
}
var basicFilter = factory(function(tag, range) {
  return range === "*" || tag === range || tag.includes(range + "-");
}, true);
var extendedFilter = factory(function(tag, range) {
  const left = tag.split("-");
  const right = range.split("-");
  let leftIndex = 0;
  let rightIndex = 0;
  if (right[rightIndex] !== "*" && left[leftIndex] !== right[rightIndex]) {
    return false;
  }
  leftIndex++;
  rightIndex++;
  while (rightIndex < right.length) {
    if (right[rightIndex] === "*") {
      rightIndex++;
      continue;
    }
    if (!left[leftIndex]) return false;
    if (left[leftIndex] === right[rightIndex]) {
      leftIndex++;
      rightIndex++;
      continue;
    }
    if (left[leftIndex].length === 1) return false;
    leftIndex++;
  }
  return true;
}, true);
var lookup = factory(function(tag, range) {
  let right = range;
  while (true) {
    if (right === "*" || tag === right) return true;
    let index = right.lastIndexOf("-");
    if (index < 0) return false;
    if (right.charAt(index - 2) === "-") index -= 2;
    right = right.slice(0, index);
  }
}, false);
function cast(values, name2) {
  const value = values && typeof values === "string" ? [values] : values;
  if (!value || typeof value !== "object" || !("length" in value)) {
    throw new Error(
      "Invalid " + name2 + " `" + value + "`, expected non-empty string"
    );
  }
  return value;
}

// node_modules/hast-util-has-property/lib/index.js
var own = {}.hasOwnProperty;
function hasProperty(node, name2) {
  const value = node.type === "element" && own.call(node.properties, name2) && node.properties[name2];
  return value !== null && value !== void 0 && value !== false;
}

// node_modules/hast-util-whitespace/lib/index.js
var re = /[ \t\n\f\r]/g;
function whitespace(thing) {
  return typeof thing === "object" ? thing.type === "text" ? empty2(thing.value) : false : empty2(thing);
}
function empty2(value) {
  return value.replace(re, "") === "";
}

// node_modules/nth-check/lib/esm/parse.js
var whitespace2 = /* @__PURE__ */ new Set([9, 10, 12, 13, 32]);
var ZERO = "0".charCodeAt(0);
var NINE = "9".charCodeAt(0);
function parse4(formula) {
  formula = formula.trim().toLowerCase();
  if (formula === "even") {
    return [2, 0];
  } else if (formula === "odd") {
    return [2, 1];
  }
  let idx = 0;
  let a = 0;
  let sign = readSign();
  let number2 = readNumber();
  if (idx < formula.length && formula.charAt(idx) === "n") {
    idx++;
    a = sign * (number2 !== null && number2 !== void 0 ? number2 : 1);
    skipWhitespace();
    if (idx < formula.length) {
      sign = readSign();
      skipWhitespace();
      number2 = readNumber();
    } else {
      sign = number2 = 0;
    }
  }
  if (number2 === null || idx < formula.length) {
    throw new Error(`n-th rule couldn't be parsed ('${formula}')`);
  }
  return [a, sign * number2];
  function readSign() {
    if (formula.charAt(idx) === "-") {
      idx++;
      return -1;
    }
    if (formula.charAt(idx) === "+") {
      idx++;
    }
    return 1;
  }
  function readNumber() {
    const start = idx;
    let value = 0;
    while (idx < formula.length && formula.charCodeAt(idx) >= ZERO && formula.charCodeAt(idx) <= NINE) {
      value = value * 10 + (formula.charCodeAt(idx) - ZERO);
      idx++;
    }
    return idx === start ? null : value;
  }
  function skipWhitespace() {
    while (idx < formula.length && whitespace2.has(formula.charCodeAt(idx))) {
      idx++;
    }
  }
}

// node_modules/nth-check/lib/esm/compile.js
var import_boolbase = __toESM(require_boolbase(), 1);
function compile(parsed) {
  const a = parsed[0];
  const b = parsed[1] - 1;
  if (b < 0 && a <= 0)
    return import_boolbase.default.falseFunc;
  if (a === -1)
    return (index) => index <= b;
  if (a === 0)
    return (index) => index === b;
  if (a === 1)
    return b < 0 ? import_boolbase.default.trueFunc : (index) => index >= b;
  const absA = Math.abs(a);
  const bMod = (b % absA + absA) % absA;
  return a > 1 ? (index) => index >= b && index % absA === bMod : (index) => index <= b && index % absA === bMod;
}

// node_modules/nth-check/lib/esm/index.js
function nthCheck(formula) {
  return compile(parse4(formula));
}

// node_modules/zwitch/index.js
var own2 = {}.hasOwnProperty;
function zwitch(key, options) {
  const settings = options || {};
  function one3(value, ...parameters) {
    let fn = one3.invalid;
    const handlers = one3.handlers;
    if (value && own2.call(value, key)) {
      const id2 = String(value[key]);
      fn = own2.call(handlers, id2) ? handlers[id2] : one3.unknown;
    }
    if (fn) {
      return fn.call(this, value, ...parameters);
    }
  }
  one3.handlers = settings.handlers || {};
  one3.invalid = settings.invalid;
  one3.unknown = settings.unknown;
  return one3;
}

// node_modules/hast-util-select/lib/pseudo.js
var nthCheck2 = nthCheck.default || nthCheck;
var pseudo = zwitch("name", {
  handlers: {
    "any-link": anyLink,
    blank,
    checked,
    dir,
    disabled,
    empty: empty3,
    enabled,
    "first-child": firstChild,
    "first-of-type": firstOfType,
    has,
    is: is2,
    lang,
    "last-child": lastChild,
    "last-of-type": lastOfType,
    not,
    "nth-child": nthChild,
    "nth-last-child": nthLastChild,
    "nth-last-of-type": nthLastOfType,
    "nth-of-type": nthOfType,
    "only-child": onlyChild,
    "only-of-type": onlyOfType,
    optional,
    "read-only": readOnly,
    "read-write": readWrite,
    required,
    root,
    scope
  },
  invalid: invalidPseudo,
  unknown: unknownPseudo
});
function anyLink(_, element) {
  return (element.tagName === "a" || element.tagName === "area" || element.tagName === "link") && hasProperty(element, "href");
}
function assertDeep(state, query) {
  if (state.shallow) {
    throw new Error("Cannot use `:" + query.name + "` without parent");
  }
}
function blank(_, element) {
  return !someChildren(element, check);
  function check(child) {
    return child.type === "element" || child.type === "text" && !whitespace(child);
  }
}
function checked(_, element) {
  if (element.tagName === "input" || element.tagName === "menuitem") {
    return Boolean(
      (element.properties.type === "checkbox" || element.properties.type === "radio") && hasProperty(element, "checked")
    );
  }
  if (element.tagName === "option") {
    return hasProperty(element, "selected");
  }
  return false;
}
function dir(query, _1, _2, _3, state) {
  ok2(query.argument, "expected `argument`");
  ok2(query.argument.type === "String", "expected plain text");
  return state.direction === query.argument.value;
}
function disabled(_, element) {
  return (element.tagName === "button" || element.tagName === "input" || element.tagName === "select" || element.tagName === "textarea" || element.tagName === "optgroup" || element.tagName === "option" || element.tagName === "menuitem" || element.tagName === "fieldset") && hasProperty(element, "disabled");
}
function empty3(_, element) {
  return !someChildren(element, check);
  function check(child) {
    return child.type === "element" || child.type === "text";
  }
}
function enabled(query, element) {
  return !disabled(query, element);
}
function firstChild(query, _1, _2, _3, state) {
  assertDeep(state, query);
  return state.elementIndex === 0;
}
function firstOfType(query, _1, _2, _3, state) {
  assertDeep(state, query);
  return state.typeIndex === 0;
}
function getCachedNthCheck(query) {
  let cachedFunction = query._cachedFn;
  if (!cachedFunction) {
    const value = query.argument;
    ok2(value, "expected `argument`");
    if (value.type !== "Formula") {
      throw new Error(
        "Expected `nth` formula, such as `even` or `2n+1` (`of` is not yet supported)"
      );
    }
    cachedFunction = nthCheck2(value.a + "n+" + value.b);
    query._cachedFn = cachedFunction;
  }
  return cachedFunction;
}
function has(query, element, _1, _2, state) {
  ok2(query.argument, "expected `argument`");
  ok2(query.argument.type === "Selector", "expected selector");
  const childState = {
    ...state,
    // Not found yet.
    found: false,
    // One result is enough.
    one: true,
    results: [],
    rootQuery: query.argument,
    scopeElements: [element],
    // Do walk deep.
    shallow: false
  };
  walk(childState, { type: "root", children: element.children });
  return childState.results.length > 0;
}
function invalidPseudo() {
  unreachable("Invalid pseudo-selector");
}
function is2(query, element, _1, _2, state) {
  ok2(query.argument, "expected `argument`");
  ok2(query.argument.type === "Selector", "expected selector");
  const childState = {
    ...state,
    // Not found yet.
    found: false,
    // One result is enough.
    one: true,
    results: [],
    rootQuery: query.argument,
    scopeElements: [element],
    // Do walk deep.
    shallow: false
  };
  walk(childState, element);
  return childState.results[0] === element;
}
function lang(query, _1, _2, _3, state) {
  ok2(query.argument, "expected `argument`");
  ok2(query.argument.type === "String", "expected string");
  return state.language !== "" && state.language !== void 0 && extendedFilter(state.language, parse2(query.argument.value)).length > 0;
}
function lastChild(query, _1, _2, _3, state) {
  assertDeep(state, query);
  return Boolean(
    state.elementCount && state.elementIndex === state.elementCount - 1
  );
}
function lastOfType(query, _1, _2, _3, state) {
  assertDeep(state, query);
  return typeof state.typeIndex === "number" && typeof state.typeCount === "number" && state.typeIndex === state.typeCount - 1;
}
function not(query, element, index, parent, state) {
  return !is2(query, element, index, parent, state);
}
function nthChild(query, _1, _2, _3, state) {
  const cachedFunction = getCachedNthCheck(query);
  assertDeep(state, query);
  return typeof state.elementIndex === "number" && cachedFunction(state.elementIndex);
}
function nthLastChild(query, _1, _2, _3, state) {
  const cachedFunction = getCachedNthCheck(query);
  assertDeep(state, query);
  return Boolean(
    typeof state.elementCount === "number" && typeof state.elementIndex === "number" && cachedFunction(state.elementCount - state.elementIndex - 1)
  );
}
function nthLastOfType(query, _1, _2, _3, state) {
  const cachedFunction = getCachedNthCheck(query);
  assertDeep(state, query);
  return typeof state.typeCount === "number" && typeof state.typeIndex === "number" && cachedFunction(state.typeCount - 1 - state.typeIndex);
}
function nthOfType(query, _1, _2, _3, state) {
  const cachedFunction = getCachedNthCheck(query);
  assertDeep(state, query);
  return typeof state.typeIndex === "number" && cachedFunction(state.typeIndex);
}
function onlyChild(query, _1, _2, _3, state) {
  assertDeep(state, query);
  return state.elementCount === 1;
}
function onlyOfType(query, _1, _2, _3, state) {
  assertDeep(state, query);
  return state.typeCount === 1;
}
function optional(query, element) {
  return !required(query, element);
}
function readOnly(query, element, index, parent, state) {
  return !readWrite(query, element, index, parent, state);
}
function readWrite(_, element, _1, _2, state) {
  return element.tagName === "input" || element.tagName === "textarea" ? !hasProperty(element, "readOnly") && !hasProperty(element, "disabled") : Boolean(state.editableOrEditingHost);
}
function required(_, element) {
  return (element.tagName === "input" || element.tagName === "textarea" || element.tagName === "select") && hasProperty(element, "required");
}
function root(_1, element, _2, parent, state) {
  return Boolean(
    (!parent || parent.type === "root") && state.schema && (state.schema.space === "html" || state.schema.space === "svg") && (element.tagName === "html" || element.tagName === "svg")
  );
}
function scope(_1, element, _2, _3, state) {
  return state.scopeElements.includes(element);
}
function someChildren(element, check) {
  const children = element.children;
  let index = -1;
  while (++index < children.length) {
    if (check(children[index])) return true;
  }
  return false;
}
function unknownPseudo(query_) {
  const query = (
    /** @type {AstPseudoClass} */
    query_
  );
  throw new Error("Unknown pseudo-selector `" + query.name + "`");
}

// node_modules/hast-util-select/lib/test.js
function test(query, element, index, parent, state) {
  for (const item of query.items) {
    if (item.type === "Attribute") {
      if (!attribute(item, element, state.schema)) return false;
    } else if (item.type === "Id") {
      if (!id(item, element)) return false;
    } else if (item.type === "ClassName") {
      if (!className(item, element)) return false;
    } else if (item.type === "PseudoClass") {
      if (!pseudo(item, element, index, parent, state)) return false;
    } else if (item.type === "PseudoElement") {
      throw new Error("Invalid selector: `::" + item.name + "`");
    } else if (item.type === "TagName") {
      if (!name(item, element)) return false;
    } else {
    }
  }
  return true;
}

// node_modules/hast-util-select/lib/walk.js
var empty4 = [];
function walk(state, tree) {
  if (tree) {
    one2(state, [], tree, void 0, void 0, tree);
  }
}
function add(nest, field, rule) {
  const list = nest[field];
  if (list) {
    list.push(rule);
  } else {
    nest[field] = [rule];
  }
}
function all2(state, nest, node, tree) {
  const fromParent = combine(nest.descendant, nest.directChild);
  let fromSibling;
  let index = -1;
  const total = { count: 0, types: /* @__PURE__ */ new Map() };
  const before = { count: 0, types: /* @__PURE__ */ new Map() };
  while (++index < node.children.length) {
    count(total, node.children[index]);
  }
  index = -1;
  while (++index < node.children.length) {
    const child = node.children[index];
    const name2 = child.type === "element" ? child.tagName.toUpperCase() : void 0;
    state.elementIndex = before.count;
    state.typeIndex = name2 ? before.types.get(name2) || 0 : 0;
    state.elementCount = total.count;
    state.typeCount = name2 ? total.types.get(name2) : 0;
    if ("children" in child) {
      const forSibling = combine(fromParent, fromSibling);
      const nest2 = one2(
        state,
        forSibling,
        node.children[index],
        index,
        node,
        tree
      );
      fromSibling = combine(nest2.generalSibling, nest2.adjacentSibling);
    }
    if (state.one && state.found) {
      break;
    }
    count(before, node.children[index]);
  }
}
function applySelectors(state, rules, node, index, parent) {
  const nestResult = {
    adjacentSibling: void 0,
    descendant: void 0,
    directChild: void 0,
    generalSibling: void 0
  };
  let selectorIndex = -1;
  while (++selectorIndex < rules.length) {
    const rule = rules[selectorIndex];
    if (state.one && state.found) {
      break;
    }
    if (state.shallow && rule.nestedRule) {
      throw new Error("Expected selector without nesting");
    }
    if (test(rule, node, index, parent, state)) {
      const nest = rule.nestedRule;
      if (nest) {
        const label = nest.combinator === "+" ? "adjacentSibling" : nest.combinator === "~" ? "generalSibling" : nest.combinator === ">" ? "directChild" : "descendant";
        add(nestResult, label, nest);
      } else {
        state.found = true;
        if (!state.results.includes(node)) {
          state.results.push(node);
        }
      }
    }
    if (rule.combinator === void 0) {
      add(nestResult, "descendant", rule);
    } else if (rule.combinator === "~") {
      add(nestResult, "generalSibling", rule);
    }
  }
  return nestResult;
}
function combine(left, right) {
  return left && right && left.length > 0 && right.length > 0 ? [...left, ...right] : left && left.length > 0 ? left : right && right.length > 0 ? right : empty4;
}
function count(counts, node) {
  if (node.type === "element") {
    const name2 = node.tagName.toUpperCase();
    const count2 = (counts.types.get(name2) || 0) + 1;
    counts.count++;
    counts.types.set(name2, count2);
  }
}
function one2(state, currentRules, node, index, parent, tree) {
  let nestResult = {
    adjacentSibling: void 0,
    descendant: void 0,
    directChild: void 0,
    generalSibling: void 0
  };
  const exit = enterState(state, node);
  if (node.type === "element") {
    let rootRules = state.rootQuery.rules;
    if (parent && parent !== tree) {
      rootRules = state.rootQuery.rules.filter(
        (d) => d.combinator === void 0 || d.combinator === ">" && parent === tree
      );
    }
    nestResult = applySelectors(
      state,
      // Try the root rules for this element too.
      combine(currentRules, rootRules),
      node,
      index,
      parent
    );
  }
  if ("children" in node && !state.shallow && !(state.one && state.found)) {
    all2(state, nestResult, node, tree);
  }
  exit();
  return nestResult;
}

// node_modules/hast-util-select/lib/index.js
function selectAll(selector, tree, space) {
  const state = createState(selector, tree, space);
  walk(state, tree || void 0);
  return state.results;
}
function createState(selector, tree, space) {
  return {
    direction: "ltr",
    editableOrEditingHost: false,
    elementCount: void 0,
    elementIndex: void 0,
    found: false,
    language: void 0,
    one: false,
    // State of the query.
    results: [],
    rootQuery: parse(selector),
    schema: space === "svg" ? svg2 : html2,
    scopeElements: tree ? tree.type === "root" ? tree.children : [tree] : [],
    shallow: false,
    typeIndex: void 0,
    typeCount: void 0
  };
}

// node_modules/rehype-rewrite/lib/index.js
var getCodeString = (data = [], code = "") => {
  data.forEach((node) => {
    if (node.type === "text") {
      code += node.value;
    } else if (node.type === "element" && node.children && Array.isArray(node.children)) {
      code += getCodeString(node.children);
    }
  });
  return code;
};
var remarkRewrite = (options) => {
  const { selector, rewrite } = options || {};
  return (tree) => {
    if (!rewrite || typeof rewrite !== "function")
      return;
    if (selector && typeof selector === "string") {
      const selected = selectAll(selector, tree);
      if (selected && selected.length > 0) {
        visit(tree, selected, (node, index, parent) => {
          rewrite(node, index, parent);
        });
      }
      return;
    }
    visit(tree, (node, index, parent) => {
      rewrite(node, index, parent);
    });
  };
};
var lib_default = remarkRewrite;

export {
  convert,
  EXIT,
  SKIP,
  visitParents,
  visit,
  toString,
  parse3 as parse,
  stringify2 as stringify,
  parse2,
  stringify as stringify2,
  normalize,
  hastToReact,
  find,
  html2 as html,
  svg2 as svg,
  ok2 as ok,
  unreachable,
  whitespace,
  zwitch,
  getCodeString,
  lib_default
};
//# sourceMappingURL=chunk-67HUSWAQ.js.map
